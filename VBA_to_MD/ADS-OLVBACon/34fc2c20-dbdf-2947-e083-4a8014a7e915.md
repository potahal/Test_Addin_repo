

---
ms.Toctitle:プロパティの値を設定する
title:プロパティの値を設定する
ms.ContentId:34fc2c20-dbdf-2947-e083-4a8014a7e915
---
# プロパティの値を設定する




Outlook には、プロパティの値を設定するためのいくつかの方法が用意されています。

|||||||
|---|---|---|---|---|---|
||*Object.Property*|**UserProperty.Value**|**ItemProperty.Value**|**PropertyAccessor.SetProperty**|**PropertyAccessor.SetProperties**|
|**アクション**|指定された明示的な組み込みのプロパティの値を設定します。|アイテム レベルのカスタム プロパティに値を設定します。プロパティが存在しない場合、値を設定すると "オブジェクト型の変数または With ブロックの変数は設定されていません" というエラーが発生します。|読み取り専用プロパティまたはブロックされたプロパティでない限り、組み込みのカスタム プロパティまたはアイテム レベルのカスタム プロパティに値を設定します。プロパティが存在しない場合は実行時エラーが発生します。|読み取り専用プロパティまたはブロックされたプロパティでない限り、*SchemaName* で指定されたプロパティに *value* を設定します。プロパティが存在せず、提供元および親オブジェクトがプロパティの作成をサポートしていて、プロパティに対して有効なスキーマ名が指定されている場合、**SetProperty** によりプロパティが作成されます。|読み取り専用プロパティまたはブロックされたプロパティでない限り、*SchemaNames* のプロパティごとに、*Values* 配列の該当する値を設定します。プロパティが既に存在していない場合、**SetProperty** 列で説明したプロパティ作成が行われることがあります。*SchemaNames* および *Values* の 2 つの配列のサイズが一致しない場合、**SetProperties** で無効な引数を表すエラーが発生します。|
|**該当するオブジェクト**|Outlook オブジェクト モデルのすべてのオブジェクト。|Microsoft Office ドキュメントのアイテム (**DocumentItem** オブジェクト) を除く、すべての [Outlook アイテム オブジェクト](6ea4babf-facf-4018-ef5a-4a484e55153a)。|Microsoft Office ドキュメントのアイテム (**DocumentItem** オブジェクト) を除く、すべての Outlook アイテム オブジェクト。|明示的な組み込みのアイテム レベル プロパティを設定するには、**ItemProperty** を使用します。**DocumentItem** のプロパティ、明示的な名前を持たないアイテム レベル プロパティ、カスタム プロパティ、または **AddressEntry**、**AddressList**、**Attachment**、**ExchangeDistributionList**、**ExchangeUser**、**Folder**、**Recipient**、および **Store** の各オブジェクトのプロパティには、**SetProperty** を使用します。|**SetProperty** 列の説明と同じオブジェクト。|
|**プロパティの種類の一致**|Outlook オブジェクト モデルの説明と同じです。|値がプロパティの種類と一致しない場合、実行時エラーが発生します。|値がプロパティの種類と一致しない場合、実行時エラーが発生します。|*SchemaName* が MAPI proptag 名前空間を使用する場合、プロパティ タグで示されたプロパティの種類に *Value* が一致しないときには、**SetProperty** は種類の不一致を表す実行時エラーを返します。*SchemaName* が MAPI 文字列名前空間を使用する場合、**SetProperty** はプロパティの種類に合わせて種類の強制変換を試みます。強制変換に失敗した場合、**SetProperty** は種類の不一致を表す実行時エラーを返します。**PropertyAccessor** は、**PT_OBJECT** など、MAPI プロパティの特定の種類をサポートしません。このような種類のプロパティの値を設定しようとすると、"実行できません" というエラーが発生します。|プロパティの種類の一致は、**SetProperty** の場合と同様に、*SchemaNames* の各プロパティが *Values* 配列の値の種類と一致している必要があります。種類の不一致を含むすべてのエラーは、*Errors* 配列に格納されます。|
|**プロパティ変更イベント**|アイテム レベルの組み込みプロパティが変更されると、**PropertyChange** イベントが発生します。|アイテム レベルのカスタム プロパティが変更されると、**CustomPropertyChange** イベントが発生します。|アイテム レベルの組み込みプロパティが変更されると、**PropertyChange** イベントが発生します。アイテム レベルのカスタム プロパティの値が変更されると、カスタム プロパティがアイテムの **UserProperties** コレクションにある場合、**CustomPropertyChange** イベントが発生します。**PropertyAccessor.SetProperty** または **PropertyAccessor.SetProperties** によって暗黙的に追加されたアイテム レベルのプロパティは、自動的にアイテムの **UserProperties** コレクションの一部にはなりません。|アイテム レベルでないプロパティを変更しても、イベントは発生しません。アイテム レベルのプロパティを変更すると、**ItemProperty.Value** 列の説明と同じイベントが発生します。**SetProperty** または **SetProperties** によって暗黙的に追加されたアイテム レベルのプロパティは、自動的にアイテムの **UserProperties** コレクションの一部にはなりません。プロパティが変更されたときに **CustomPropertyChange** イベントが発生するよう、プロパティをコレクションに含めるには、明示的な **UserProperties.Add** が必要です。|値を変更すると、*SchemaNames* 配列のプロパティごとに、**SetProperty** 列の説明のように状況に応じてイベントが発生することがあります。|
|**セキュリティ**|セキュリティの制限はありません。|信頼されたコードと信頼されていないコードは、**UserProperty** を使用できます。|信頼されたコードと信頼されていないコードは、**ItemProperty** を使用できます。|ウイルス対策ソフトウェアを適切にセットアップしていないクライアント コンピューターの場合、信頼されていないコードがアイテム オブジェクトの **PropertyAccessor** プロパティにアクセスしようとすると、既定ではアドレス帳のセキュリティ警告が発生します。|**SetProperty** 列と同じセキュリティ警告が発生します。|
|**パフォーマンス**|パフォーマンスへのオーバーヘッドはありません。明示的に組み込まれているプロパティに対しては、いつでもこのオブジェクトを使用できます。|パフォーマンスへのオーバーヘッドはありません。アイテム レベルのカスタム プロパティに対しては、いつでもこのオブジェクトを使用できます。|パフォーマンスへのオーバーヘッドはありません。アイテム レベルの名前付きプロパティに対しては、いつでもこのオブジェクトを使用できます。|**PropertyAccessor** を使用してプロパティにアクセスすると、パフォーマンスへのオーバーヘッドが発生します。複数のプロパティを設定するには、**SetProperty** を繰り返す代わりに **SetProperties** を使用します。|**PropertyAccessor** を使用してプロパティにアクセスすると、パフォーマンスへのオーバーヘッドが発生します。複数のプロパティを設定するには、**SetProperty** を繰り返す代わりに **SetProperties** を使用します。|

## 解説
**Value** プロパティは **ItemProperty** オブジェクトおよび **UserProperty** オブジェクトの既定のプロパティであるため、プロパティの値を参照するときに、必ずしも明示的に **Value** プロパティを指定する必要はありません。



同様に、**Find** メソッドは **ItemProperties** および **UserProperties** の既定のメソッドです。プロパティの値を参照するときに、必ずしも **Find** メソッドを指定する必要はありません。




